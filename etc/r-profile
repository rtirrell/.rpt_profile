
options(max.print = 500)
options(stringsAsFactors = FALSE)

##
# Miscellaneous output functions.
##
csprintf <- function(...) {
  cat(sprintf(...))
}

psprintf <- function(...) {
  print(sprintf(...))
}

wsprintf <- function(...) {
  warning(sprintf(...))
}

ssprintf <- function(...) {
  stop(sprintf(...))
}

##
# Miscellaneous utility functions.
##

format_tuple <- function(values) {
  if (is.character(values)) 
    values <- sprintf("'%s'", values)
  sprintf('(%s)', paste(values, collapse = ', '))
}


##
# Project utility functions.
##
BOOT.FILENAMES <- c('boot.r', 'env.r', 'func.r', 'db.r', 'load.r')

resource <- function(directory) {
	boot(directory, boot.filenames = c('env.r', 'func.r', 'db.r'))
}

reload <- function(directory) {
  boot(directory, boot.filenames = c('env.r', 'func.r', 'db.r', 'load.r'))
}

boot <- function(directory, boot.filenames = BOOT.FILENAMES) {
	if (missing(directory)) directory <- getwd()
  for (filename in boot.filenames) {
    if (file.exists(file.path(directory, filename))) 
      source(file.path(directory, filename))
  }
  for (file in list.files(directory)) {
    if (file_test('-d', file) && any(boot.filenames %in% list.files(file))) 
	    boot(file, boot.filenames)
	}
}

# Functional utilities.
memoize_func <- function(func) {
  require(digest)
	cache <- new.env()
	function(...) {
		hash <- digest(list(...))
		if (!exists(hash, env = cache, inherits = FALSE)) 
			assign(hash, func(...), env = cache)
		get(hash, env = cache)
	}
}

memoize_list <- function(data) {
	function(name, expr) {
		if (missing(name)) return(data)
		
		name <- as.character(name)
		if (!name %in% names(data)) 
			data[[name]] <<- eval(expr, env = parent.frame())
		
		data[[name]]
	}
}
