# Notes:
# - If a function adding a column can do so simply, use 'get_' and return
#   that new column only.
# - If the logic is more complicated, use 'join_' and return the data frame.

library(stringr)
options(max.print = 1000)
options(stringsAsFactors = TRUE)

##
# Miscellaneous output functions.
##
csprintf <- function(...) {
  cat(sprintf(...))
}

psprintf <- function(...) {
  print(sprintf(...))
}

wsprintf <- function(...) {
  warning(sprintf(...))
}

ssprintf <- function(...) {
  stop(sprintf(...))
}

##
# Miscellaneous replacement functions.
#

# Replace '.' with '_'.
dot_under <- function(value) {
  str_replace_all(value, fixed('.'), fixed('_'))
}

# Replace '.' with ' '.
dot_space <- function(value) {
  str_replace_all(value, fixed('.'), fixed(' '))
}

# Replace ' ' with '_'.
space_under <- function(value) {
  str_replace_all(value, '\\s+', '_')
}

under_space <- function(value) {
  str_replace_all(value, '_', ' ')
}

# Replace abs.log.value with abs(log(value)).
to_paren <- function(value, char) {
  ndots <- vapply(str_locate_all(value, fixed(char)), nrow, integer(1))
  str_c(str_replace_all(value, fixed(char), fixed('(')), str_dup(')', ndots))
}

dot_paren <- function(value) {
  to_paren(value, '.')
}

under_paren <- function(value) {
  to_paren(value, '_')
}

# Remove all non alphanumeric/multiple-space characters.
normalize <- function(value) {
  value <- str_replace_all(value, '[^A-Za-z0-9 ]+', '')
  str_replace_all(value, '\\s+', ' ')
}

capitalize <- function(value) {
  str_c(
    toupper(str_sub(value, 1, 1)), 
    str_sub(value, 2, str_length(value))
  )
}

properize <- function(value) {
  capitalize(dot_space(value))
}

format_tuple <- function(values) {
  if (is.character(values)) 
    values <- sprintf("'%s'", values)
  sprintf('(%s)', str_c(values, collapse = ', '))
}

single_space <- function(value) {
  str_replace_all(value, '\\s+', ' ')
}

# Replace commas and reverse a string.
reverse_commas <- function(value) {
  single_space(rev(str_replace_all(value, fixed(','), ' ')))
}

##
# Project utility functions.
##

# Files:
# - boot.r is intended to be sourced only once, and contains (e.g.)
#   library() statements, database setup, constants, etc..
# - db.r contains database-related functions.
# - load.r loads datasets from disk or database.
# - func.r contains functions (go figure).
BOOT_FILENAMES <- c('env.r', 'boot.r', 'func.r', 'db.r', 'load.r')

source_directory <- function(directory) {
  if (missing(directory))
    directory <- getwd()
  for (file in Sys.glob(file.path(directory, '*.r')))
    source(file)
}

resource <- function(directory) {
	boot(directory, boot_for = c('env.r', 'func.r', 'db.r'))
}

reload <- function(directory) {
  boot(directory, boot_for = c('env.r', 'func.r', 'db.r', 'load.r'))
}

boot <- function(directory, boot_for = BOOT_FILENAMES) {
	if (missing(directory)) 
    directory <- getwd()

  if (is.character(boot_for)) {
    for (filename in boot_for) {
      if (file.exists(file.path(directory, filename))) 
        source(file.path(directory, filename))
    }
  } 

  for (file in list.files(directory, full.names = TRUE)) {
    if (str_sub(file, -4) == 'data')
      next
    if (is.function(boot_for) && file_test('-f', file) && boot_for(file)) {
      csprintf('RUNNING %s.\n', file)
      source(file)
    }
    if (file_test('-d', file))
	    boot(file, boot_for)
	}
}

run <- function(file) {
  resource()
  source(file)
}

do_all <- function(directory) {
  resource(directory)
  boot_test <- function(file) {
    str_detect(file, 'do/.*\\.r')
  }
  boot(directory, boot_test)
}


# Functional utilities.
memoize_func <- function(func) {
  require(digest)
	cache <- new.env()
	function(...) {
		hash <- digest(list(...))
		if (!exists(hash, env = cache, inherits = FALSE)) 
			assign(hash, func(...), env = cache)
		get(hash, env = cache)
	}
}

memoize_list <- function(data) {
	function(name, expr) {
		if (missing(name)) return(data)
		
		name <- as.character(name)
		if (!name %in% names(data)) 
			data[[name]] <<- eval(expr, env = parent.frame())
		
		data[[name]]
	}
}

reverse_commas <- function(value) {
    str_c(rev(unlist(str_split(value, fixed(', ')))), collapse = ' ')
}

limit_ordered <- function(dat, attribute, limit, decreasing = TRUE) {
  dat[order(dat[[attribute]], decreasing = decreasing)[seq_len(limit)], ]
}

save_ggplot <- function(...) {
  suppressMessages(ggsave(...))
}
